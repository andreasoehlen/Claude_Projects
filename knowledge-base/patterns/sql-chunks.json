{
  "metadata": {
    "description": "Reusable SQL query chunks from 139 production queries",
    "last_updated": "2025-11-12",
    "source": "SQL_Examples folder bootstrap analysis + overdraft query learning",
    "total_chunks": 13,
    "critical_limitations": "4 critical Teradata limitations documented (errors 6926, 3706; LDB_ID trap)"
  },

  "CRITICAL_TERADATA_LIMITATIONS": {
    "NO_RECURSIVE_CTE": {
      "priority": "CRITICAL",
      "error_code": "6926",
      "error_message": "WITH [RECURSIVE] clause or recursive view is not supported",
      "description": "Teradata does NOT support WITH RECURSIVE or recursive CTEs",
      "never_use": [
        "WITH RECURSIVE cte_name AS (...)",
        "Nested WITH clauses (WITH inside WITH)",
        "CTEs that reference themselves"
      ],
      "alternatives": [
        "Use window functions (ROW_NUMBER, QUALIFY) instead",
        "Use volatile tables for iterative logic",
        "Use multiple self-joins for known hierarchy depth",
        "Pre-calculate hierarchies in ETL"
      ]
    },
    "NO_NESTED_WITH": {
      "priority": "CRITICAL",
      "error_code": "6926",
      "description": "Cannot nest WITH clauses inside subqueries or other CTEs",
      "wrong_example": "WITH outer AS (SELECT * FROM (WITH inner AS (...) SELECT * FROM inner) x)",
      "correct_example": "WITH cte1 AS (...), cte2 AS (...) SELECT * FROM cte1 JOIN cte2"
    },
    "NO_WINDOW_FUNCTIONS_IN_SUBQUERIES": {
      "priority": "CRITICAL",
      "error_code": "3706",
      "error_message": "Syntax error: Order-based Aggregate and Ordered Analytical Functions are not allowed in subqueries",
      "description": "Teradata does NOT allow window functions (ROW_NUMBER, RANK, DENSE_RANK, etc.) or ordered analytical functions in certain subquery contexts",
      "never_use": [
        "SELECT * FROM (SELECT ROW_NUMBER() OVER (ORDER BY col) AS rn FROM table) WHERE rn = 1",
        "SELECT * FROM table WHERE col IN (SELECT ROW_NUMBER() OVER (...) FROM other_table)",
        "Window functions in derived tables used in WHERE/HAVING clauses"
      ],
      "alternatives": [
        "Use QUALIFY clause (Teradata-specific) - see advanced_patterns.qualify_deduplication",
        "Use CTE with window function, then query the CTE - see cte_patterns.cte_with_window_functions",
        "Move window function to outer query when possible",
        "Use volatile table to materialize subquery with window functions first"
      ],
      "correct_examples": {
        "using_qualify": "SELECT AR_ID, CASH_FLOW_DATE FROM table QUALIFY ROW_NUMBER() OVER (PARTITION BY AR_ID ORDER BY date DESC) = 1",
        "using_cte": "WITH ranked AS (SELECT *, ROW_NUMBER() OVER (ORDER BY col) AS rn FROM table) SELECT * FROM ranked WHERE rn = 1",
        "using_volatile_table": "CREATE VOLATILE TABLE temp_ranked AS (SELECT *, ROW_NUMBER() OVER (ORDER BY col) AS rn FROM table) WITH DATA ON COMMIT PRESERVE ROWS; SELECT * FROM temp_ranked WHERE rn = 1;"
      },
      "notes": "QUALIFY is the most efficient Teradata-native solution. CTEs work but may be less performant for large datasets."
    },
    "LDB_ID_SELECTION_TRAP": {
      "priority": "CRITICAL",
      "category": "JOIN_FAILURE_SILENTLY_LOSES_DATA",
      "description": "QUALIFY with ORDER BY LDB_ID DESC can select wrong LDB_ID causing silent data loss",
      "detailed_explanation": "When customers exist in multiple LDB_IDs (e.g., 1 and 1600), using QUALIFY ORDER BY LDB_ID DESC without pre-filtering will select LDB_ID = 1. All operational tables (AC_AR_OD_INF_DLY, AC_AR_BAL) use LDB_ID = 1600, so downstream joins on LDB_ID will fail silently, causing entire risk groups to disappear from results.",
      "MANDATORY_FIX": "ALWAYS filter to LDB_ID = 1600 in WHERE clause BEFORE QUALIFY when working with operational account data",
      "impact": "CRITICAL - Causes silent data loss where valid records simply don't appear in output",
      "real_world_example": "Risk group 1706600755 had 6 customers with overdrafts in last 30 days but didn't appear in final results because CST selected LDB_ID = 1 while all overdraft data was in LDB_ID = 1600",
      "wrong_pattern": "WHERE c.SNPST_DT = max_date QUALIFY ROW_NUMBER() OVER (PARTITION BY c.IP_ID ORDER BY c.LDB_ID DESC) = 1",
      "correct_pattern": "WHERE c.SNPST_DT = max_date AND c.LDB_ID = 1600 QUALIFY ROW_NUMBER() OVER (PARTITION BY c.IP_ID ORDER BY c.LDB_ID DESC) = 1",
      "why_critical": "ORDER BY LDB_ID DESC picks highest LDB_ID, but with values 1 and 1600, it picks 1600... UNLESS there's a sort order issue or the logic reverses, picking 1 instead. The safe approach is ALWAYS pre-filter to LDB_ID = 1600",
      "detection": "Compare row counts before and after joins. Missing risk groups indicate LDB_ID mismatch in join conditions"
    }
  },

  "temporal_filters": {
    "current_snapshot": {
      "priority": "HIGH",
      "frequency": 62,
      "description": "Get most recent data snapshot",
      "sql": "WHERE t1.SNPST_DT = (SELECT MAX(SNPST_DT) FROM EDWBLU01600_VP.DT)",
      "use_case": "Standard for current state queries"
    },

    "previous_bank_date": {
      "priority": "HIGH",
      "frequency": 21,
      "description": "Get previous banking day",
      "sql": "WHERE t1.SNPST_DT = (SELECT MAX(PREV_BNK_DT) FROM EDWBLU01600_VP.DT)",
      "use_case": "T-1 reporting"
    },

    "month_end_snapshot": {
      "priority": "HIGH",
      "frequency": 15,
      "description": "Get month-end data",
      "sql": "WHERE t1.SNPST_DT = (SELECT MAX(PREV_BNK_MNTH_END_DT) FROM EDWBLU01600_VP.DT)",
      "use_case": "Monthly reports"
    }
  },

  "customer_lookups": {
    "employee_lookup": {
      "priority": "HIGH",
      "frequency": 82,
      "description": "Add responsible employee name to customer query",
      "sql": "LEFT OUTER JOIN EDWBLU01600_VP.RSPL_EMP t6\n  ON t1.RSPL_EMP_ID = t6.IP_ID\n  AND t6.SNPST_DT = t1.SNPST_DT",
      "select_clause": "t6.NM AS KUNDEANSVAR",
      "notes": "t1 is CST table"
    },

    "department_lookup": {
      "priority": "HIGH",
      "frequency": 38,
      "description": "Add responsible department to customer query",
      "sql": "LEFT OUTER JOIN EDWBLU01600_VP.RSPL_OU t5\n  ON t1.RSPL_OU_ID = t5.IP_ID\n  AND t5.SNPST_DT = t1.SNPST_DT",
      "select_clause": "t5.NM AS AFDELING",
      "notes": "t1 is CST table"
    },

    "rating_lookup": {
      "priority": "HIGH",
      "frequency": 21,
      "description": "Add customer credit rating",
      "sql": "LEFT OUTER JOIN EDWBLU01600_VP.CST_X_RATING t3\n  ON t1.IP_ID = t3.IP_ID\n  AND t1.SNPST_DT = t3.SNPST_DT\n  AND (t3.GRP_ID = '1835260' OR t3.IP_ID IS NULL)\nLEFT OUTER JOIN EDWBLU01600_VP.RATING t4\n  ON t3.RATING_ID = t4.RATING_ID\n  AND t1.SNPST_DT = t4.SNPST_DT",
      "select_clause": "t4.RATING_SCL_VAL AS RISIKOVURDERING",
      "parameter": "GRP_ID = '1835260' for Risk, '2707716' for AHV",
      "notes": "OR clause prevents NULL elimination"
    },

    "address_lookup": {
      "priority": "HIGH",
      "frequency": 18,
      "description": "Add customer primary address",
      "sql": "LEFT OUTER JOIN EDWBLU01600_VP.ADR t7\n  ON t1.PRIM_ADR_ID = t7.ADR_ID\n  AND t1.SNPST_DT = t7.SNPST_DT",
      "select_clause": "t7.PST_ADR_NM_1, t7.PST_ADR_NM_2, t7.PST_ADR_NM_3, t7.PST_ADR_NM_4, t7.PSTCD, t7.POSTAL_NM",
      "notes": "Address fields 1-4 contain multi-line address"
    },

    "electronic_address_lookup": {
      "priority": "MEDIUM",
      "frequency": 8,
      "description": "Add email and phone to customer query",
      "sql": "LEFT JOIN EDWBLU01600_VP.ELC_ADR t3\n  ON t1.IP_ID = t3.IP_ID\n  AND t1.SNPST_DT = t3.SNPST_DT\n  AND t3.ELC_ADR_TP_CL IN ('lgem_', 'lgmb_', 'lgph_')",
      "select_clause": "t3.EMAIL_ADR, t3.ELC_ADR_NO",
      "notes": "Filter on type to get email/mobile/phone"
    }
  },

  "business_filters": {
    "active_accounts_only": {
      "priority": "HIGH",
      "frequency": 50,
      "description": "Filter for active accounts",
      "sql": "WHERE t1.AR_LCS_TP_CL = 'actv_'\n  -- Alternative: WHERE t1.AR_LCS_TP_CL_NM = 'Aktiv'",
      "use_case": "Exclude closed/settled accounts"
    },

    "external_products_only": {
      "priority": "HIGH",
      "frequency": 36,
      "description": "Filter for customer-facing products",
      "sql": "WHERE t1.EXT_PD_F = 'Y'",
      "use_case": "Exclude internal/system products"
    },

    "primary_owners_only": {
      "priority": "HIGH",
      "frequency": 24,
      "description": "Filter for primary account owners",
      "sql": "WHERE t1.AC_AR_X_IP_TP_CL IN ('prow_', 'ownr_')",
      "use_case": "Get accounts by ownership type",
      "alternatives": {
        "tax_liable": "t1.AC_AR_X_IP_TP_CL = 'txlb_'",
        "co_guarantor": "t1.AC_AR_X_IP_TP_CL = 'cngr_'"
      }
    },

    "customer_group_exclusion": {
      "priority": "HIGH",
      "frequency": 15,
      "description": "Exclude customers in test/internal groups",
      "sql": "LEFT JOIN EDWBLU01600_VP.CST_X_CST_GRP t0\n  ON t1.IP_ID = t0.IP_ID\n  AND t1.SNPST_DT = t0.SNPST_DT\nWHERE t0.GRP_ID IS NULL OR t0.GRP_ID = 1",
      "use_case": "Exclude test accounts from reports"
    },

    "business_vs_private": {
      "priority": "HIGH",
      "frequency": 14,
      "description": "Distinguish corporate from individual customers",
      "sql": "-- Business customers:\nWHERE t1.LGL_CMPNC_ST_TP_CL = ''\n-- Private individuals:\nWHERE t1.LGL_CMPNC_ST_TP_CL <> ''",
      "use_case": "Segment by customer type"
    }
  },

  "aggregations": {
    "customer_balance_totals": {
      "priority": "HIGH",
      "frequency": 31,
      "description": "Sum risk and deposit balances by customer",
      "sql": "SELECT u1.DRVD_CST_IDENTN_NO,\n  SUM(u3.RISK_AMT) AS TOTAL_RISK,\n  SUM(u3.CR_EOD_BAL_AMT) AS TOTAL_DEPOSITS,\n  SUM(u3.DB_EOD_BAL_AMT) AS TOTAL_DEBIT\nFROM EDWBLU01600_VP.CST u1\nLEFT JOIN EDWBLU01600_VP.AC_AR u2\n  ON u1.IP_ID = u2.PRIM_OWN_ID\n  AND u1.SNPST_DT = u2.SNPST_DT\nLEFT JOIN EDWBLU01600_VP.AC_AR_BAL u3\n  ON u2.AR_ID = u3.AR_ID\n  AND u1.SNPST_DT = u3.SNPST_DT\nGROUP BY u1.DRVD_CST_IDENTN_NO",
      "use_case": "Customer-level financial summary"
    },

    "depot_value_summation": {
      "priority": "MEDIUM",
      "frequency": 8,
      "description": "Sum securities holdings by value",
      "sql": "SUM(t1.NOMINELT_BLB) AS DEPOT_SALDO,\nSUM(t1.KURSV_RDI) AS KURSVAERDI",
      "use_case": "Portfolio valuation"
    },

    "guarantee_capital_total": {
      "priority": "MEDIUM",
      "frequency": 8,
      "description": "Sum guarantee capital by customer",
      "sql": "SUM(t1.EOD_BAL_AMT) AS GARANTKAPITAL\nWHERE t1.AR_TP_CL_NM IN ('Garantbeviser', 'Garantkonto Invest')",
      "use_case": "Guarantee capital reporting"
    }
  },

  "advanced_patterns": {
    "qualify_deduplication": {
      "priority": "MEDIUM",
      "frequency": 5,
      "description": "Deduplicate using QUALIFY and ROW_NUMBER",
      "sql": "SELECT AR_ID, CASH_FLOW_DATE\nFROM EDWBLU01600_VP.AC_AR_LOAN_CASH_FLOW\nQUALIFY ROW_NUMBER() OVER (PARTITION BY AR_ID ORDER BY CASH_FLOW_DATE ASC) = 1",
      "use_case": "Get first/last occurrence per group",
      "notes": "QUALIFY is Teradata-specific, very efficient"
    },

    "leap_year_birthday_handling": {
      "priority": "LOW",
      "frequency": 1,
      "description": "Handle Feb 29 birthdays for annual calculations",
      "sql": "CASE\n  WHEN SUBSTR(BRTH_DT, 5, 6) = '-02-29' THEN '-02-28'\n  ELSE SUBSTR(BRTH_DT, 5, 6)\nEND",
      "use_case": "Birthday lists and age calculations"
    },

    "calendar_day_overdraft_counter": {
      "priority": "HIGH",
      "frequency": "NEW",
      "description": "Count actual calendar days (including weekends/holidays) a group was in overdraft by carrying forward snapshot balances",
      "business_rule": "Since snapshots don't exist for weekends/holidays, must carry forward the last known overdraft balance through non-banking days",
      "technique": "Use LEAD() window function to calculate days until next snapshot, then sum DAYS_COVERED for all negative balance periods",
      "sql": "WITH DAILY_BAL AS (\n  SELECT \n    group_id, \n    snapshot_dt, \n    balance,\n    CASE \n      WHEN LEAD(snapshot_dt) OVER (PARTITION BY group_id ORDER BY snapshot_dt) IS NOT NULL \n      THEN LEAD(snapshot_dt) OVER (PARTITION BY group_id ORDER BY snapshot_dt) - snapshot_dt\n      ELSE end_date - snapshot_dt + 1\n    END AS DAYS_COVERED\n  FROM balances\n)\nSELECT \n  group_id,\n  SUM(CASE WHEN balance < 0 THEN DAYS_COVERED ELSE 0 END) AS overdraft_calendar_days\nFROM DAILY_BAL\nGROUP BY group_id",
      "use_case": "Calculate total calendar days in overdraft for risk reporting, regulatory compliance, or fee calculations",
      "performance_note": "Window functions in Teradata are efficient - avoid recursive CTEs for date generation",
      "key_insight": "Each snapshot's balance is assumed to remain constant until the next snapshot, covering all calendar days in between (including weekends/holidays)"
    }
  },

  "cte_patterns": {
    "single_cte": {
      "priority": "HIGH",
      "frequency": 7,
      "description": "Single CTE for date or data preparation",
      "sql": "WITH DATO_S_MD AS (\n  SELECT MAX(e1.SNPST_DT) AS DATO\n  FROM EDWClt01600_VT.DG_ST_ENGA_SUM e1\n  WHERE EXISTS (\n    SELECT 1 FROM EDWBLU01600_VP.DT e2\n    WHERE e1.SNPST_DT = e2.SNPST_DT\n  )\n)\nSELECT c.SNPST_DT, c.NM\nFROM EDWBLU01600_VP.CST c\nWHERE c.SNPST_DT = (SELECT DATO FROM DATO_S_MD)",
      "use_case": "Store calculated date or complex subquery result",
      "notes": "From KREDITLISTE_(NEW).sql"
    },

    "multiple_ctes": {
      "priority": "HIGH",
      "frequency": 6,
      "description": "Multiple non-recursive CTEs with comma separation",
      "sql": "WITH first_cte AS (\n  SELECT AR_ID, CASH_FLOW_DATE\n  FROM EDWBLU01600_VP.AC_AR_LOAN_CASH_FLOW\n  WHERE SNPST_DT = (SELECT MAX(SNPST_DT) FROM EDWBLU01600_VP.DT)\n),\nsecond_cte AS (\n  SELECT DISTINCT a.AR_ID\n  FROM first_cte a\n  JOIN first_cte b ON a.AR_ID = b.AR_ID\n)\nSELECT r.AR_ID, r.CASH_FLOW_DATE\nFROM first_cte r\nLEFT JOIN second_cte e ON r.AR_ID = e.AR_ID",
      "use_case": "Break complex query into readable steps",
      "notes": "From Ny cashflow.sql - note comma between CTEs, no nested WITH",
      "warning": "NEVER nest WITH clauses - use comma separation at same level"
    },

    "cte_with_window_functions": {
      "priority": "HIGH",
      "frequency": 4,
      "description": "CTE with ROW_NUMBER for ranking/deduplication",
      "sql": "WITH RankedCashFlows AS (\n  SELECT\n    AR_ID,\n    CASH_FLOW_DATE,\n    ROW_NUMBER() OVER (PARTITION BY AR_ID ORDER BY CASH_FLOW_DATE DESC) AS RowNum\n  FROM EDWBLU01600_VP.AC_AR_LOAN_CASH_FLOW\n  WHERE SNPST_DT = (SELECT MAX(SNPST_DT) FROM EDWBLU01600_VP.DT)\n)\nSELECT AR_ID, CASH_FLOW_DATE\nFROM RankedCashFlows\nWHERE RowNum = 1",
      "use_case": "Get top N records per group without QUALIFY",
      "notes": "Alternative to QUALIFY when additional logic needed on ranked data"
    },

    "cte_for_filtering": {
      "priority": "MEDIUM",
      "frequency": 2,
      "description": "Multiple CTEs to prepare filter lists",
      "sql": "WITH active_list AS (\n  SELECT DISTINCT depot_nr\n  FROM transactions\n  WHERE transaction_date > '2024-01-01'\n),\nempty_list AS (\n  SELECT depot_nr\n  FROM depots\n  GROUP BY depot_nr\n  HAVING SUM(balance) = 0\n)\nSELECT *\nFROM depot_master d\nWHERE d.depot_nr NOT IN (SELECT depot_nr FROM active_list)\nAND d.depot_nr IN (SELECT depot_nr FROM empty_list)",
      "use_case": "Pre-calculate filter criteria for cleaner WHERE clause",
      "notes": "From Passive depoter.sql"
    }
  },

  "standard_select_clauses": {
    "customer_identification": {
      "priority": "HIGH",
      "frequency": 97,
      "description": "Standard customer ID fields",
      "sql": "t1.IP_ID,\nt1.DRVD_CST_IDENTN_NO,\nt1.NM AS CUSTOMER_NAME",
      "notes": "DRVD_CST_IDENTN_NO is the business key for customers"
    },

    "account_basics": {
      "priority": "HIGH",
      "frequency": 68,
      "description": "Standard account fields",
      "sql": "t1.AR_ID,\nt1.AC_AR_NO,\nt1.AR_LCS_TP_CL,\nt1.AR_LCS_TP_CL_NM",
      "notes": "AR_ID is internal, AC_AR_NO is customer-facing"
    },

    "balance_fields": {
      "priority": "HIGH",
      "frequency": 49,
      "description": "Standard balance fields",
      "sql": "t1.EOD_BAL_AMT,\nt1.CR_EOD_BAL_AMT,\nt1.DB_EOD_BAL_AMT,\nt1.RISK_AMT,\nt1.AGRD_BAL_AMT",
      "notes": "CR=credit, DB=debit, AGRD=agreed"
    }
  },

  "date_range_patterns": {
    "date_interval_filter": {
      "priority": "MEDIUM",
      "frequency": 10,
      "description": "Filter by date range",
      "sql": "WHERE t1.TXN_DT >= DATE '2025-01-01'\n  AND t1.TXN_DT < DATE '2025-04-01'",
      "use_case": "Period-specific analysis"
    },

    "year_filter": {
      "priority": "LOW",
      "frequency": 4,
      "description": "Multi-year comparison",
      "sql": "WHERE t1.CAL_YEAR IN ('2024', '2025')",
      "use_case": "Year-over-year reports"
    }
  },

  "product_filters": {
    "loan_products": {
      "priority": "MEDIUM",
      "frequency": 4,
      "description": "Filter for loan products",
      "sql": "WHERE t1.PD_TPL_TP_CL = 'loan_'",
      "use_case": "Loan portfolio analysis"
    },

    "specific_product_codes": {
      "priority": "MEDIUM",
      "frequency": 8,
      "description": "Filter by business ID (product code)",
      "sql": "WHERE t1.BSN_ID IN ('gdlr006', 'eksung1', 'eand002')",
      "use_case": "Product-specific reports",
      "examples": {
        "gdlr006": "DLR guarantee",
        "eksung1": "Child savings",
        "eand002": "Co-op housing"
      }
    }
  }
}
