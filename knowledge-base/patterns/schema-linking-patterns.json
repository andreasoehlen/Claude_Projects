{
  "metadata": {
    "description": "Schema linking patterns extracted from database schemas and common joins",
    "source": "Databases/*.json + common_join_patterns.json analysis",
    "version": "1.0",
    "last_updated": "2025-11-17"
  },
  "primary_relationships": {
    "customer_to_account": {
      "tables": ["EDWBLU01600_VP.CST", "EDWBLU01600_VP.AC_AR"],
      "join_logic": "CST.IP_ID = AC_AR.PRIM_OWN_ID AND CST.SNPST_DT = AC_AR.SNPST_DT",
      "fk_documented": true,
      "cardinality": "1:many",
      "notes": "One cust can have multiple accts"
    },
    "customer_to_employee": {
      "tables": ["EDWBLU01600_VP.CST", "EDWBLU01600_VP.RSPL_EMP"],
      "join_logic": "CST.RSPL_EMP_ID = RSPL_EMP.IP_ID AND CST.SNPST_DT = RSPL_EMP.SNPST_DT",
      "fk_documented": false,
      "cardinality": "many:1",
      "notes": "Many custs can have same responsible employee"
    },
    "customer_to_department": {
      "tables": ["EDWBLU01600_VP.CST", "EDWBLU01600_VP.RSPL_OU"],
      "join_logic": "CST.RSPL_OU_ID = RSPL_OU.IP_ID AND CST.SNPST_DT = RSPL_OU.SNPST_DT",
      "fk_documented": false,
      "cardinality": "many:1",
      "notes": "Many custs can have same responsible org unit"
    },
    "customer_to_address": {
      "tables": ["EDWBLU01600_VP.CST", "EDWBLU01600_VP.ADR"],
      "join_logic": "CST.PRIM_ADR_ID = ADR.ADR_ID AND CST.SNPST_DT = ADR.SNPST_DT",
      "fk_documented": false,
      "cardinality": "many:1",
      "notes": "Cust primary address relationship"
    },
    "customer_to_rating": {
      "tables": ["EDWBLU01600_VP.CST", "EDWBLU01600_VP.CST_X_RATING", "EDWBLU01600_VP.RATING"],
      "join_logic": "CST.IP_ID = CST_X_RATING.IP_ID AND CST_X_RATING.RATING_ID = RATING.RATING_ID",
      "fk_documented": false,
      "cardinality": "many:many",
      "notes": "Bridge table pattern. Must filter GRP_ID = 1835260 for Risk or 2707716 for AHV"
    },
    "account_to_product": {
      "tables": ["EDWBLU01600_VP.AC_AR", "EDWBLU01600_VP.AC_PD"],
      "join_logic": "AC_AR.PD_ID = AC_PD.PD_ID AND AC_AR.SNPST_DT = AC_PD.SNPST_DT",
      "fk_documented": true,
      "cardinality": "many:1",
      "notes": "Many accts can have same product"
    },
    "account_to_balance": {
      "tables": ["EDWBLU01600_VP.AC_AR", "EDWBLU01600_VP.AC_AR_BAL"],
      "join_logic": "AC_AR.AR_ID = AC_AR_BAL.AR_ID AND AC_AR.SNPST_DT = AC_AR_BAL.SNPST_DT",
      "fk_documented": true,
      "cardinality": "1:1",
      "notes": "One acct has one balance record per snapshot"
    },
    "account_to_interested_parties": {
      "tables": ["EDWBLU01600_VP.AC_AR", "EDWBLU01600_VP.AC_AR_X_IP", "EDWBLU01600_VP.CST"],
      "join_logic": "AC_AR.AR_ID = AC_AR_X_IP.AR_ID AND AC_AR_X_IP.IP_ID = CST.IP_ID",
      "fk_documented": false,
      "cardinality": "many:many",
      "notes": "Bridge table for multi-party accts. Filter AC_AR_X_IP_TP_CL for relationship type"
    },
    "customer_to_electronic_address": {
      "tables": ["EDWBLU01600_VP.CST", "EDWBLU01600_VP.ELC_ADR"],
      "join_logic": "CST.IP_ID = ELC_ADR.IP_ID AND CST.SNPST_DT = ELC_ADR.SNPST_DT",
      "fk_documented": false,
      "cardinality": "1:many",
      "notes": "One cust can have multiple electronic addresses. Filter ELC_ADR_TP_CL for type"
    },
    "account_to_overdraft": {
      "tables": ["EDWBLU01600_VP.AC_AR_OD_INF_DLY"],
      "join_logic": "CST.IP_ID = AC_AR_OD_INF_DLY.PRIM_OWN_ID AND CST.LDB_ID = AC_AR_OD_INF_DLY.LDB_ID",
      "fk_documented": false,
      "cardinality": "1:many",
      "notes": "CRITICAL: Use PRIM_OWN_ID not AC_AR_X_IP to avoid double-counting. Filter LDB_ID = 1600"
    },
    "spd_ar_to_customer": {
      "tables": ["EDWClt01600_VP.SPD_AR", "EDWClt01600_VP.SPD_AR_X_IP", "EDWBLU01600_VP.CST"],
      "join_logic": "SPD_AR.AR_ID = SPD_AR_X_IP.SPD_AR_ID AND SPD_AR_X_IP.LDB_ID = CST.LDB_ID AND SPD_AR_X_IP.CST_ID = CST.CST_ID",
      "fk_documented": false,
      "cardinality": "many:many",
      "notes": "Bridge table with multi-column join. Must use all 3 cols (LDB_ID, SNPST_DT, CST_ID)"
    }
  },
  "naming_conventions": {
    "id_suffixes": {
      "_ID": {
        "meaning": "Primary or foreign key identifier",
        "examples": ["IP_ID", "AR_ID", "PD_ID"],
        "usage": "Always integer, used in joins"
      },
      "_NO": {
        "meaning": "Business identifier, not necessarily unique",
        "examples": ["BR_NO", "UNIT_IDENTN_NO", "AC_AR_NO"],
        "usage": "Display purposes, may not be suitable for joins"
      },
      "_CD": {
        "meaning": "Code value requiring translation",
        "examples": ["IP_TP_CD", "AC_STS_CD", "AR_LCS_TP_CD"],
        "usage": "Check variable_explanations.json for code meanings"
      },
      "_CL": {
        "meaning": "Classification code",
        "examples": ["IP_TP_CL", "OU_AC_DSG_TP_CL", "AR_LCS_TP_CL"],
        "usage": "Similar to _CD, check variable_explanations.json"
      },
      "_F": {
        "meaning": "Flag field, typically CHAR(1)",
        "examples": ["CST_AC_F", "INR_AC_F", "EXT_PD_F"],
        "usage": "Usually Y/N or 1/0, check actual values if unsure"
      },
      "_DT": {
        "meaning": "Date field",
        "examples": ["SNPST_DT", "STRT_DT", "END_DT"],
        "usage": "Use for temporal filtering and joins"
      },
      "_AMT": {
        "meaning": "Amount/monetary value",
        "examples": ["BAL_AMT", "NOM_AMT", "RISK_AMT"],
        "usage": "Decimal fields, use for aggregations"
      },
      "_NM": {
        "meaning": "Name or description field",
        "examples": ["NM", "DRVD_CST_NM", "AR_LCS_TP_CL_NM"],
        "usage": "Display names, often paired with _CL or _CD codes"
      },
      "_TP": {
        "meaning": "Type code or classification",
        "examples": ["IP_TP_CL", "AR_TP_CL", "TXN_TP_CL"],
        "usage": "Type classification, check for _TP_CL (code) or _TP_NM (name) variants"
      }
    },
    "special_patterns": {
      "bridge_tables": {
        "pattern": "{TABLE1}_X_{TABLE2}",
        "description": "Many-to-many relationship table",
        "examples": ["CST_X_CST_GRP", "AC_AR_X_IP", "SPD_AR_X_IP"],
        "join_logic": "Requires joins to both parent tables",
        "cardinality": "many:many"
      },
      "snapshot_pattern": {
        "indicator": "Table contains SNPST_DT column",
        "meaning": "Temporal table with historical snapshots",
        "join_requirement": "ALWAYS include SNPST_DT in join conditions",
        "filter_requirement": "ALWAYS filter by SNPST_DT in WHERE clause"
      },
      "ldb_id_pattern": {
        "indicator": "Table contains LDB_ID column",
        "meaning": "Multi-ledger table - data exists in different ledgers",
        "join_requirement": "Include LDB_ID in join when both tables have it",
        "filter_requirement": "Filter LDB_ID = 1600 for operational data",
        "trap": "Don't use QUALIFY with ORDER BY LDB_ID without pre-filtering to 1600"
      }
    }
  },
  "common_mismatches": {
    "ip_id_variations": {
      "problem": "IP_ID has different names in different tables",
      "examples": {
        "CST": "IP_ID",
        "AC_AR": "PRIM_OWN_ID (for customer), also has other _IP_ID fields",
        "RSPL_EMP": "IP_ID",
        "RSPL_OU": "IP_ID",
        "AC_AR_OD_INF_DLY": "PRIM_OWN_ID"
      },
      "solution": "Check common_join_patterns.json for correct join column names"
    },
    "ar_id_variations": {
      "problem": "AR_ID vs SPD_AR_ID in bridge tables",
      "examples": {
        "AC_AR": "AR_ID",
        "SPD_AR": "AR_ID",
        "SPD_AR_X_IP": "SPD_AR_ID (maps to SPD_AR.AR_ID)"
      },
      "solution": "Bridge tables may rename FK columns - verify in schema"
    },
    "cst_id_vs_ip_id": {
      "problem": "CST table has both CST_ID and IP_ID",
      "examples": {
        "CST": "CST_ID (technical PK part), IP_ID (customer identifier)",
        "SPD_AR_X_IP": "CST_ID (references CST.CST_ID)"
      },
      "solution": "Use IP_ID for most joins, CST_ID only for specific bridge tables"
    }
  },
  "diagnostic_queries": {
    "find_fk_relationships": {
      "purpose": "Discover how two tables are related",
      "approach": [
        "1. Check Databases/*.json for fk field in table schemas",
        "2. Look for common column names (usually ending in _ID)",
        "3. Check common_join_patterns.json for documented joins",
        "4. If not found, request diagnostic queries to explore"
      ]
    },
    "verify_cardinality": {
      "purpose": "Check if join is 1:1, 1:many, or many:many",
      "approach": [
        "1. Check if bridge table exists ({TABLE1}_X_{TABLE2})",
        "2. Count distinct keys on both sides of join",
        "3. Use diagnostic query to check for duplicates"
      ]
    }
  }
}
