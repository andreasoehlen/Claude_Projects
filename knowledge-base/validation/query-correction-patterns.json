{
  "metadata": {
    "description": "Error-to-correction mappings for iterative query refinement",
    "source": "error_taxonomy.json + TERADATA_FORBIDDEN_PATTERNS.json",
    "version": "1.0",
    "last_updated": "2025-11-17"
  },
  "correction_patterns": {
    "error_3807_table_not_found": {
      "error_message_pattern": "Object '.*' does not exist",
      "symptom": "Table name not found in database",
      "diagnostic_steps": [
        "Search all Databases/*.json for similar table names",
        "Check if table might be in different database (EDWBLU01600_VP vs EDWClt01600_VP)",
        "Look for table in common_join_patterns.json examples",
        "Ask user to confirm table name if no matches found"
      ],
      "common_mistakes": [
        "Assuming table name without verifying",
        "Using old/deprecated table names",
        "Searching in wrong database"
      ],
      "correction_template": "Verify table name in appropriate Databases/*.json file",
      "prevention": "ALWAYS verify table before use",
      "reference": "error_taxonomy.json:schema_errors:table_not_found"
    },
    "error_3807_column_not_found": {
      "error_message_pattern": "Column '.*' does not exist",
      "symptom": "Column name not found in table",
      "diagnostic_steps": [
        "Check Databases/*.json for table's actual columns in cols field",
        "Look for similar column names (e.g., NM vs PD_NM)",
        "Check if column might have different name (e.g., DRVD_CST_NM vs CST_NM)",
        "Verify column spelling and case sensitivity"
      ],
      "common_mistakes": [
        "Guessing column names based on patterns",
        "Assuming standard naming when table uses custom names",
        "Typos in column names"
      ],
      "correction_template": "Look up actual column names in Databases/*.json:table_name:cols",
      "prevention": "ALWAYS verify column exists in table schema",
      "reference": "error_taxonomy.json:schema_errors:column_not_found"
    },
    "error_3706_window_function_in_subquery": {
      "error_message_pattern": "Syntax error.*Order-based.*not allowed in subqueries",
      "symptom": "ROW_NUMBER, RANK, or DENSE_RANK in subquery",
      "diagnostic_steps": [
        "Identify the window function being used",
        "Check if logic can be rewritten with QUALIFY",
        "Verify QUALIFY syntax is Teradata-compliant"
      ],
      "correction_template": {
        "pattern": "Convert subquery with window function to QUALIFY clause",
        "before": "SELECT * FROM (SELECT ROW_NUMBER() OVER (PARTITION BY x ORDER BY y) AS rn, cols FROM t) WHERE rn = 1",
        "after": "SELECT cols FROM t QUALIFY ROW_NUMBER() OVER (PARTITION BY x ORDER BY y) = 1"
      },
      "prevention": "Always use QUALIFY instead of window functions in subqueries",
      "reference": "sql_chunks.json:qualify_deduplication"
    },
    "error_3706_missing_column_alias": {
      "error_message_pattern": "Syntax error.*derived table",
      "symptom": "Calculated column or expression without AS alias",
      "diagnostic_steps": [
        "Find all expressions in SELECT without aliases",
        "Add AS alias_name to each",
        "Ensure alias is not a reserved word"
      ],
      "correction_template": {
        "pattern": "Add AS alias to every expression",
        "before": "WITH t AS (SELECT col1 + col2 FROM table)",
        "after": "WITH t AS (SELECT col1 + col2 AS total_val FROM table)"
      },
      "prevention": "Every expression must have AS alias in CTEs and subqueries",
      "reference": "error_taxonomy.json:syntax_errors:missing_column_alias"
    },
    "error_3504_missing_group_by": {
      "error_message_pattern": "Column.*not in GROUP BY",
      "symptom": "Non-aggregated column in SELECT not in GROUP BY",
      "diagnostic_steps": [
        "List all SELECT columns",
        "Identify which are aggregated (SUM, COUNT, etc.)",
        "Add non-aggregated columns to GROUP BY"
      ],
      "correction_template": {
        "pattern": "Add all non-aggregated SELECT columns to GROUP BY",
        "before": "SELECT cust_id, product, SUM(amt) FROM t GROUP BY cust_id",
        "after": "SELECT cust_id, product, SUM(amt) FROM t GROUP BY cust_id, product"
      },
      "prevention": "Every non-aggregated SELECT column must be in GROUP BY",
      "reference": "error_taxonomy.json:logical_errors:missing_group_by_columns"
    },
    "error_3848_union_order_by_names": {
      "error_message_pattern": "ORDER BY position.*out of range",
      "symptom": "Column names used in ORDER BY after UNION",
      "diagnostic_steps": [
        "Identify ORDER BY clause after UNION",
        "Replace column names with position integers",
        "Verify positions match SELECT columns"
      ],
      "correction_template": {
        "pattern": "Use position integers in ORDER BY after UNION",
        "before": "SELECT c1, c2 FROM t1 UNION SELECT c3, c4 FROM t2 ORDER BY c1",
        "after": "SELECT c1, c2 FROM t1 UNION SELECT c3, c4 FROM t2 ORDER BY 1"
      },
      "prevention": "Always use ORDER BY 1, 2, 3 after set operations",
      "reference": "error_taxonomy.json:syntax_errors:union_order_by_names"
    },
    "error_6926_recursive_or_nested_with": {
      "error_message_pattern": "WITH.*RECURSIVE.*not supported",
      "symptom": "WITH RECURSIVE or nested WITH clause",
      "diagnostic_steps": [
        "Identify nested or recursive CTE",
        "Flatten to comma-separated CTEs",
        "Ensure no CTE references itself"
      ],
      "correction_template": {
        "pattern": "Flatten CTEs to comma-separated list",
        "before": "WITH RECURSIVE t AS (...) or WITH outer AS (SELECT * FROM (WITH inner AS (...)))",
        "after": "WITH cte1 AS (...), cte2 AS (...) SELECT * FROM cte1 JOIN cte2"
      },
      "prevention": "Use flat comma-separated CTEs only",
      "reference": "error_taxonomy.json:syntax_errors:recursive_or_nested_with"
    },
    "missing_temporal_join": {
      "error_message_pattern": "logical",
      "symptom": "Cartesian product or too many rows returned",
      "diagnostic_steps": [
        "Check if both tables have SNPST_DT column",
        "Verify SNPST_DT is in JOIN condition",
        "If missing, add AND t1.SNPST_DT = t2.SNPST_DT"
      ],
      "correction_template": {
        "pattern": "Add SNPST_DT to temporal joins",
        "before": "FROM CST t1 JOIN AC_AR t2 ON t1.IP_ID = t2.PRIM_OWN_ID",
        "after": "FROM CST t1 JOIN AC_AR t2 ON t1.IP_ID = t2.PRIM_OWN_ID AND t1.SNPST_DT = t2.SNPST_DT"
      },
      "prevention": "Always check if tables have SNPST_DT and include in join",
      "reference": "common_join_patterns.json:snapshot_date_join"
    },
    "missing_snapshot_filter": {
      "error_message_pattern": "logical",
      "symptom": "Query returns data from all snapshots instead of current",
      "diagnostic_steps": [
        "Check if table has SNPST_DT column",
        "Add WHERE SNPST_DT filter",
        "Use MAX(SNPST_DT) from EDWBLU01600_VP.DT"
      ],
      "correction_template": {
        "pattern": "Add SNPST_DT filter to WHERE clause",
        "before": "SELECT * FROM CST t1",
        "after": "SELECT * FROM CST t1 WHERE t1.SNPST_DT = (SELECT MAX(SNPST_DT) FROM EDWBLU01600_VP.DT)"
      },
      "prevention": "Always filter temporal tables by SNPST_DT",
      "reference": "common_join_patterns.json:max_snapshot_date_filter"
    },
    "ldb_id_trap": {
      "error_message_pattern": "logical",
      "symptom": "Silent data loss - valid records missing from results",
      "diagnostic_steps": [
        "Check if LDB_ID filter applied before QUALIFY",
        "Verify LDB_ID = 1600 for operational data",
        "Compare row counts before/after joins"
      ],
      "correction_template": {
        "pattern": "Add LDB_ID = 1600 filter before QUALIFY",
        "before": "WHERE c.SNPST_DT = max_date QUALIFY ROW_NUMBER() OVER (PARTITION BY c.IP_ID ORDER BY c.LDB_ID DESC) = 1",
        "after": "WHERE c.SNPST_DT = max_date AND c.LDB_ID = 1600 QUALIFY ROW_NUMBER() OVER (PARTITION BY c.IP_ID ORDER BY c.LDB_ID DESC) = 1"
      },
      "prevention": "Pre-filter LDB_ID = 1600 before QUALIFY for operational data",
      "reference": "sql_chunks.json:LDB_ID_SELECTION_TRAP"
    },
    "error_3707_reserved_word_alias": {
      "error_message_pattern": "Reserved word.*used as alias",
      "symptom": "Reserved word used as column/table alias",
      "diagnostic_steps": [
        "Identify reserved word in AS clause",
        "Append _nm, _val, _type to alias",
        "Or use different non-reserved word"
      ],
      "correction_template": {
        "pattern": "Rename alias to avoid reserved words",
        "before": "SELECT calc AS value, method_col AS method",
        "after": "SELECT calc AS calc_val, method_col AS method_nm"
      },
      "prevention": "Avoid: method, type, value, date, time, year, month, day, user, group, order, table, rank, row",
      "reference": "error_taxonomy.json:syntax_errors:reserved_word_as_alias"
    },
    "error_3568_nested_aggregates": {
      "error_message_pattern": "Cannot nest aggregate operations",
      "symptom": "Aggregate function inside another aggregate",
      "diagnostic_steps": [
        "Identify the nested aggregate pattern (e.g., SUM(AVG(...)))",
        "Create first CTE for inner aggregate",
        "Create second CTE or final SELECT for outer aggregate",
        "Verify multi-stage aggregation logic"
      ],
      "correction_template": {
        "pattern": "Split nested aggregates into multi-stage CTEs",
        "before": "SELECT dept, SUM(AVG(salary)) FROM employees GROUP BY dept, employee_id",
        "after": "WITH avg_salaries AS (SELECT dept, employee_id, AVG(salary) AS avg_sal FROM employees GROUP BY dept, employee_id) SELECT dept, SUM(avg_sal) FROM avg_salaries GROUP BY dept"
      },
      "prevention": "Never nest aggregates; use CTEs for multi-level aggregation",
      "reference": "error_taxonomy.json:syntax_errors:nested_aggregates"
    },
    "error_3706_distinct_in_window_functions": {
      "error_message_pattern": "Distinct option is invalid with OVER",
      "symptom": "DISTINCT used inside window function",
      "diagnostic_steps": [
        "Identify window function with DISTINCT (e.g., COUNT(DISTINCT col) OVER (...))",
        "Create CTE with GROUP BY to get distinct values first",
        "Apply window function without DISTINCT on CTE results",
        "Verify partitioning and ordering logic maintained"
      ],
      "correction_template": {
        "pattern": "Pre-aggregate with GROUP BY, then apply window function",
        "before": "SELECT customer_id, COUNT(DISTINCT product_id) OVER (PARTITION BY region) AS distinct_products FROM sales",
        "after": "WITH distinct_prods AS (SELECT region, customer_id, product_id FROM sales GROUP BY region, customer_id, product_id) SELECT customer_id, COUNT(*) OVER (PARTITION BY region) AS distinct_products FROM distinct_prods"
      },
      "prevention": "Use CTE with GROUP BY first, then window function without DISTINCT",
      "reference": "error_taxonomy.json:syntax_errors:distinct_in_window_functions"
    },
    "error_3706_limit_keyword": {
      "error_message_pattern": "Syntax error.*LIMIT",
      "symptom": "LIMIT keyword used (not supported in Teradata)",
      "diagnostic_steps": [
        "Identify LIMIT clause and row count",
        "Move row count to TOP n at start of SELECT",
        "Verify ORDER BY clause if present",
        "Remove LIMIT clause entirely"
      ],
      "correction_template": {
        "pattern": "Replace LIMIT with TOP in SELECT clause",
        "before": "SELECT * FROM customers ORDER BY name LIMIT 10",
        "after": "SELECT TOP 10 * FROM customers ORDER BY name"
      },
      "prevention": "Always use TOP n at start of SELECT, never LIMIT at end",
      "reference": "error_taxonomy.json:syntax_errors:limit_keyword"
    },
    "error_3544_string_operators_on_non_char": {
      "error_message_pattern": "Partial string matching requires character operands",
      "symptom": "LIKE or CONTAINS used on non-character column",
      "diagnostic_steps": [
        "Identify column causing error and check data type in schema",
        "If numeric: either CAST to CHAR or use numeric comparison (=, >, <)",
        "If date: either CAST to CHAR or use date comparison operators",
        "Verify schema in Databases/*.json for column data type"
      ],
      "correction_template": {
        "pattern": "CAST to CHAR for string matching or use appropriate operators",
        "before": "WHERE account_number LIKE '%123%' (account_number is INTEGER)",
        "after": "WHERE CAST(account_number AS CHAR(20)) LIKE '%123%' OR WHERE account_number = 123"
      },
      "prevention": "Check column data type in schema before using LIKE/CONTAINS",
      "reference": "error_taxonomy.json:syntax_errors:string_operators_on_non_char"
    },
    "error_6916_top_with_sample": {
      "error_message_pattern": "Top N option is not supported with SAMPLE",
      "symptom": "Both TOP and SAMPLE used in same query",
      "diagnostic_steps": [
        "Identify whether specific row count (TOP) or percentage (SAMPLE) is needed",
        "Remove either TOP or SAMPLE clause",
        "If TOP needed: remove SAMPLE clause",
        "If SAMPLE needed: remove TOP clause"
      ],
      "correction_template": {
        "pattern": "Choose either TOP or SAMPLE, not both",
        "before": "SELECT TOP 10 * FROM customers SAMPLE 100",
        "after": "SELECT TOP 10 * FROM customers OR SELECT * FROM customers SAMPLE 100"
      },
      "prevention": "Use TOP for exact row count, SAMPLE for percentage, never both",
      "reference": "error_taxonomy.json:syntax_errors:top_with_sample"
    },
    "error_3707_single_pipe_concatenation": {
      "error_message_pattern": "Syntax error.*expected.*between.*and '|'",
      "symptom": "Single pipe | used instead of double pipe ||",
      "diagnostic_steps": [
        "Scan for single pipe | characters in query",
        "Replace all single | with double ||",
        "Verify string concatenation syntax",
        "Check for escaped pipes in string literals"
      ],
      "correction_template": {
        "pattern": "Replace single | with double || for concatenation",
        "before": "SELECT first_name | ' ' | last_name AS full_name",
        "after": "SELECT first_name || ' ' || last_name AS full_name"
      },
      "prevention": "Always use double pipe || for string concatenation",
      "reference": "error_taxonomy.json:syntax_errors:single_pipe_concatenation"
    }
  },
  "correction_workflow": {
    "step_1": "Match error message to pattern",
    "step_2": "Run diagnostic steps",
    "step_3": "Apply correction template",
    "step_4": "Revalidate with validation_workflow.json",
    "step_5": "If still fails, try next correction pattern or request diagnostics",
    "max_attempts": 3
  }
}
