{
  "metadata": {
    "description": "Teradata SQL error taxonomy for systematic error detection and correction",
    "source": "Based on SQL-of-Thought research + existing TERADATA_FORBIDDEN_PATTERNS.json",
    "version": "1.0",
    "last_updated": "2025-11-17"
  },
  "error_categories": {
    "syntax_errors": {
      "description": "Teradata-specific syntax violations",
      "subcategories": {
        "window_functions_in_subquery": {
          "error_code": "3706",
          "symptom": "Syntax error: Order-based Aggregate Functions not allowed in subqueries",
          "root_cause": "Teradata restriction on ROW_NUMBER/RANK in derived tables",
          "detection": "Scan for: SELECT * FROM (SELECT ROW_NUMBER() OVER",
          "correction_strategy": "Replace with QUALIFY clause",
          "example_fix": {
            "wrong": "SELECT * FROM (SELECT ROW_NUMBER() OVER (ORDER BY x) AS rn FROM t) WHERE rn=1",
            "correct": "SELECT * FROM t QUALIFY ROW_NUMBER() OVER (ORDER BY x) = 1"
          },
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F1",
          "prevention": "Always check for window functions before subquery wrapping"
        },
        "missing_column_alias": {
          "error_code": "3706",
          "symptom": "Syntax error in derived table - calculated column without AS alias",
          "root_cause": "Teradata requires AS alias for all expressions in CTEs/subqueries",
          "detection": "Scan for expressions without AS in WITH/subquery SELECT",
          "correction_strategy": "Add AS alias_name to every expression",
          "example_fix": {
            "wrong": "WITH t AS (SELECT col1 + col2 FROM table)",
            "correct": "WITH t AS (SELECT col1 + col2 AS total_val FROM table)"
          },
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F2",
          "prevention": "Every expression must have AS alias in CTEs and subqueries"
        },
        "reserved_word_as_alias": {
          "error_code": "3707",
          "symptom": "Reserved word used as column/table alias",
          "root_cause": "Using method, type, value, date, time, etc. as alias",
          "detection": "Scan for reserved words in AS alias_name",
          "correction_strategy": "Append _nm, _val, _type or use different word",
          "example_fix": {
            "wrong": "SELECT calc AS value, method_col AS method",
            "correct": "SELECT calc AS calc_val, method_col AS method_nm"
          },
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F3",
          "prevention": "Avoid: method, type, value, date, time, year, month, day, user, group, order, table, rank, row, current, session, position, key, index"
        },
        "invalid_extract_part": {
          "error_code": "3707",
          "symptom": "EXTRACT function with non-standard date part",
          "root_cause": "Using DOW, QUARTER, WEEK not supported in Teradata",
          "detection": "Scan for: EXTRACT(DOW|QUARTER|WEEK FROM",
          "correction_strategy": "Use only YEAR, MONTH, DAY, HOUR, MINUTE, SECOND",
          "example_fix": {
            "wrong": "EXTRACT(DOW FROM date_col), EXTRACT(QUARTER FROM date_col)",
            "correct": "EXTRACT(YEAR FROM date_col), EXTRACT(MONTH FROM date_col)"
          },
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F4",
          "prevention": "Only use standard EXTRACT parts"
        },
        "recursive_or_nested_with": {
          "error_code": "6926",
          "symptom": "WITH RECURSIVE or nested WITH clause",
          "root_cause": "Teradata does not support WITH RECURSIVE or WITH inside WITH",
          "detection": "Scan for: WITH RECURSIVE or WITH.*\\(.*WITH",
          "correction_strategy": "Use comma-separated CTEs at same level",
          "example_fix": {
            "wrong": "WITH RECURSIVE t AS (...) or WITH outer AS (SELECT * FROM (WITH inner AS (...)))",
            "correct": "WITH cte1 AS (...), cte2 AS (...) SELECT..."
          },
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F5",
          "prevention": "Use flat comma-separated CTEs only"
        },
        "self_referencing_cte": {
          "error_code": "6920",
          "symptom": "CTE references itself in definition",
          "root_cause": "CTE name appears in its own FROM clause",
          "detection": "CTE definition contains its own name in FROM",
          "correction_strategy": "Use multiple CTEs with different names",
          "example_fix": {
            "wrong": "WITH emp AS (SELECT * FROM employees JOIN emp ON ...)",
            "correct": "WITH emp_base AS (...), emp_joined AS (SELECT * FROM emp_base JOIN ...)"
          },
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F6",
          "prevention": "Multi-step logic requires multiple CTEs"
        },
        "union_order_by_names": {
          "error_code": "3848",
          "symptom": "Column names in ORDER BY after UNION",
          "root_cause": "Teradata requires position integers in ORDER BY after UNION",
          "detection": "Scan for: UNION.*ORDER BY [a-zA-Z]",
          "correction_strategy": "Use ORDER BY 1, 2, 3 (position numbers)",
          "example_fix": {
            "wrong": "SELECT c1, c2 FROM t1 UNION SELECT c3, c4 FROM t2 ORDER BY c1",
            "correct": "SELECT c1, c2 FROM t1 UNION SELECT c3, c4 FROM t2 ORDER BY 1"
          },
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F7",
          "prevention": "Always use position integers in ORDER BY after set operations"
        },
        "union_without_from": {
          "error_code": "3888",
          "symptom": "SELECT without FROM clause in UNION",
          "root_cause": "Every SELECT must have FROM clause in Teradata",
          "detection": "Scan for: SELECT.*UNION.*SELECT (without FROM)",
          "correction_strategy": "Add FROM system table if needed",
          "example_fix": {
            "wrong": "SELECT 'Value1' UNION SELECT 'Value2'",
            "correct": "SELECT 'Value1' FROM (SELECT 1) x UNION SELECT 'Value2' FROM (SELECT 1) y"
          },
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F8",
          "prevention": "Every SELECT must have FROM"
        },
        "smart_quotes_special_chars": {
          "error_code": "6705",
          "symptom": "Smart quotes or non-ASCII characters",
          "root_cause": "Rich text characters not supported",
          "detection": "Scan for non-ASCII characters",
          "correction_strategy": "Use ASCII only, straight quotes ' and \" only",
          "example_fix": {
            "wrong": "Smart quotes or em-dash characters",
            "correct": "Straight quotes and plain hyphens only"
          },
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F11",
          "prevention": "Plain text only, no rich text formatting"
        },
        "nested_aggregates": {
          "error_code": "3568",
          "symptom": "Cannot nest aggregate operations",
          "root_cause": "Aggregate function inside another aggregate (e.g., SUM(AVG(...)))",
          "detection": "Scan for: (SUM|AVG|MAX|MIN|COUNT)\\s*\\(\\s*(SUM|AVG|MAX|MIN|COUNT)",
          "correction_strategy": "Use multi-stage CTEs to calculate aggregates separately",
          "example_fix": {
            "wrong": "SELECT SUM(AVG(sales)) FROM t GROUP BY region",
            "correct": "WITH avg_sales AS (SELECT region, AVG(sales) AS avg_val FROM t GROUP BY region) SELECT SUM(avg_val) FROM avg_sales"
          },
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F15",
          "prevention": "Never nest aggregate functions; use CTEs for multi-level aggregation"
        },
        "distinct_in_window_functions": {
          "error_code": "3706",
          "symptom": "Distinct option is invalid with OVER phrase",
          "root_cause": "DISTINCT cannot be used inside window functions (e.g., COUNT(DISTINCT x) OVER (...))",
          "detection": "Scan for: (COUNT|SUM|AVG)\\s*\\(\\s*DISTINCT.*\\)\\s*OVER",
          "correction_strategy": "Pre-aggregate with GROUP BY, then apply window function",
          "example_fix": {
            "wrong": "SELECT COUNT(DISTINCT product_id) OVER (PARTITION BY customer_id) FROM sales",
            "correct": "WITH distinct_prods AS (SELECT customer_id, product_id FROM sales GROUP BY customer_id, product_id) SELECT COUNT(*) OVER (PARTITION BY customer_id) FROM distinct_prods"
          },
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F16",
          "prevention": "Use CTE with GROUP BY first, then apply window function without DISTINCT"
        },
        "limit_keyword": {
          "error_code": "3706",
          "symptom": "Syntax error with LIMIT keyword",
          "root_cause": "LIMIT keyword not supported in Teradata",
          "detection": "Scan for: LIMIT\\s+\\d+",
          "correction_strategy": "Replace LIMIT n with TOP n at start of SELECT",
          "example_fix": {
            "wrong": "SELECT * FROM customers ORDER BY name LIMIT 10",
            "correct": "SELECT TOP 10 * FROM customers ORDER BY name"
          },
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F17",
          "prevention": "Always use TOP n in SELECT clause, never LIMIT"
        },
        "string_operators_on_non_char": {
          "error_code": "3544",
          "symptom": "Partial string matching requires character operands",
          "root_cause": "Using LIKE or CONTAINS on non-character column (numeric, date, etc.)",
          "detection": "Manual: verify data types for LIKE/CONTAINS operands in schema",
          "correction_strategy": "CAST to CHAR first or use numeric/date comparison operators",
          "example_fix": {
            "wrong": "WHERE account_number LIKE '%123%' (if account_number is INTEGER)",
            "correct": "WHERE CAST(account_number AS CHAR(20)) LIKE '%123%' OR WHERE account_number = 123"
          },
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F18",
          "prevention": "Check column data type in schema before using string operators"
        },
        "top_with_sample": {
          "error_code": "6916",
          "symptom": "Top N option is not supported with SAMPLE clause",
          "root_cause": "Using both TOP and SAMPLE in same query (mutually exclusive)",
          "detection": "Scan for: TOP\\s+\\d+.*SAMPLE|SAMPLE.*TOP\\s+\\d+",
          "correction_strategy": "Choose either TOP for specific row count or SAMPLE for percentage",
          "example_fix": {
            "wrong": "SELECT TOP 10 * FROM customers SAMPLE 100",
            "correct": "SELECT TOP 10 * FROM customers OR SELECT * FROM customers SAMPLE 100"
          },
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F19",
          "prevention": "Use TOP for exact row count, SAMPLE for percentage sampling, never both"
        },
        "single_pipe_concatenation": {
          "error_code": "3707",
          "symptom": "Syntax error with single pipe character",
          "root_cause": "Using single pipe | instead of double pipe || for string concatenation",
          "detection": "Scan for: [a-zA-Z0-9_)]\\s*\\|\\s*[a-zA-Z0-9_(](?!\\|)",
          "correction_strategy": "Replace single | with double || for concatenation",
          "example_fix": {
            "wrong": "SELECT first_name | ' ' | last_name AS full_name",
            "correct": "SELECT first_name || ' ' || last_name AS full_name"
          },
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F20",
          "prevention": "Always use double pipe || for string concatenation"
        }
      }
    },
    "schema_errors": {
      "description": "Table/column reference errors",
      "subcategories": {
        "table_not_found": {
          "error_code": "3807",
          "symptom": "Object '[TABLE]' does not exist",
          "root_cause": "Table name not verified in Databases/*.json before use",
          "detection": "Missing table in schema files",
          "correction_strategy": "Search all Databases/*.json files for similar names",
          "prevention": "ALWAYS verify table exists before query generation",
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F12",
          "diagnostic_steps": [
            "Search Databases/*.json for exact table name",
            "Check different databases (EDWBLU01600_VP vs EDWClt01600_VP)",
            "Look for similar names with typos",
            "Check if table might be deprecated"
          ]
        },
        "column_not_found": {
          "error_code": "3807",
          "symptom": "Column '[COLUMN]' does not exist in table",
          "root_cause": "Column name not verified in table schema",
          "detection": "Missing column in table's 'cols' object",
          "correction_strategy": "Check Databases/*.json for actual column names in table",
          "prevention": "ALWAYS verify column in table schema before use",
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F13",
          "diagnostic_steps": [
            "Check table's cols object in Databases/*.json",
            "Look for similar column names (PD_NM vs NM)",
            "Verify column spelling and case",
            "Check if column might have prefix/suffix"
          ]
        },
        "unverified_join_columns": {
          "error_code": "3807",
          "symptom": "Join fails due to missing column in one or both tables",
          "root_cause": "JOIN condition written without verifying both columns exist",
          "detection": "Check both tables' schemas for join columns",
          "correction_strategy": "Verify in Databases/*.json, check common_join_patterns.json for correct join",
          "prevention": "Validate both join columns before writing JOIN ON",
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F14",
          "diagnostic_steps": [
            "Verify left column exists in left table schema",
            "Verify right column exists in right table schema",
            "Check data types are compatible",
            "Look up documented join in common_join_patterns.json"
          ]
        }
      }
    },
    "logical_errors": {
      "description": "Semantically valid but logically incorrect queries",
      "subcategories": {
        "missing_temporal_join": {
          "error_code": "logical",
          "symptom": "Cartesian product or wrong data due to missing SNPST_DT join",
          "root_cause": "Forgot AND t1.SNPST_DT = t2.SNPST_DT in join condition",
          "detection": "JOIN without SNPST_DT condition when both tables have it",
          "correction_strategy": "Add SNPST_DT equality to all temporal table joins",
          "prevention": "Check if both tables have SNPST_DT, if yes always include in join",
          "reference": "common_join_patterns.json:snapshot_date_join",
          "example_fix": {
            "wrong": "FROM CST t1 JOIN AC_AR t2 ON t1.IP_ID = t2.PRIM_OWN_ID",
            "correct": "FROM CST t1 JOIN AC_AR t2 ON t1.IP_ID = t2.PRIM_OWN_ID AND t1.SNPST_DT = t2.SNPST_DT"
          }
        },
        "missing_group_by_columns": {
          "error_code": "3504",
          "symptom": "Column not in GROUP BY or aggregate function",
          "root_cause": "Non-aggregated column missing from GROUP BY clause",
          "detection": "SELECT columns not in GROUP BY and not aggregated",
          "correction_strategy": "Add all non-aggregated SELECT columns to GROUP BY",
          "prevention": "Verify every SELECT column is aggregated or in GROUP BY",
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F9",
          "example_fix": {
            "wrong": "SELECT cust_id, product, SUM(amt) FROM t GROUP BY cust_id",
            "correct": "SELECT cust_id, product, SUM(amt) FROM t GROUP BY cust_id, product"
          }
        },
        "cartesian_product": {
          "error_code": "performance",
          "symptom": "Query returns way more rows than expected",
          "root_cause": "Missing join condition between tables",
          "detection": "Multiple FROM tables without sufficient join conditions",
          "correction_strategy": "Add missing join conditions, check common_join_patterns.json",
          "prevention": "Verify n-1 join conditions for n tables"
        },
        "ldb_id_mismatch": {
          "error_code": "logical",
          "symptom": "Silent data loss - valid records don't appear in results",
          "root_cause": "QUALIFY with ORDER BY LDB_ID DESC without pre-filtering to LDB_ID = 1600",
          "detection": "Compare row counts before/after joins, missing groups indicate mismatch",
          "correction_strategy": "ALWAYS filter to LDB_ID = 1600 in WHERE before QUALIFY when working with operational data",
          "prevention": "Pre-filter LDB_ID = 1600 before QUALIFY for operational account data",
          "reference": "sql_chunks.json:LDB_ID_SELECTION_TRAP",
          "example_fix": {
            "wrong": "WHERE c.SNPST_DT = max_date QUALIFY ROW_NUMBER() OVER (PARTITION BY c.IP_ID ORDER BY c.LDB_ID DESC) = 1",
            "correct": "WHERE c.SNPST_DT = max_date AND c.LDB_ID = 1600 QUALIFY ROW_NUMBER() OVER (PARTITION BY c.IP_ID ORDER BY c.LDB_ID DESC) = 1"
          }
        }
      }
    },
    "temporal_errors": {
      "description": "Snapshot date and time filtering issues",
      "subcategories": {
        "missing_snapshot_filter": {
          "error_code": "logical",
          "symptom": "Query returns data from all snapshots instead of just one",
          "root_cause": "Missing WHERE SNPST_DT = (SELECT MAX(SNPST_DT)...)",
          "detection": "Query on temporal table without SNPST_DT filter",
          "correction_strategy": "Add WHERE SNPST_DT = (SELECT MAX(SNPST_DT) FROM EDWBLU01600_VP.DT)",
          "prevention": "Always filter temporal tables by SNPST_DT",
          "reference": "common_join_patterns.json:max_snapshot_date_filter",
          "example_fix": {
            "wrong": "SELECT * FROM CST t1",
            "correct": "SELECT * FROM CST t1 WHERE t1.SNPST_DT = (SELECT MAX(SNPST_DT) FROM EDWBLU01600_VP.DT)"
          }
        }
      }
    },
    "performance_errors": {
      "description": "Queries that work but perform poorly",
      "subcategories": {
        "using_union_instead_of_union_all": {
          "error_code": "performance",
          "symptom": "Slow query with UNION causing spool space issues",
          "root_cause": "UNION forces deduplication even when not needed",
          "detection": "UNION without need for duplicate removal",
          "correction_strategy": "Replace UNION with UNION ALL unless deduplication required",
          "prevention": "Default to UNION ALL, only use UNION when deduplication needed",
          "example_fix": {
            "wrong": "SELECT col FROM t1 UNION SELECT col FROM t2",
            "correct": "SELECT col FROM t1 UNION ALL SELECT col FROM t2"
          }
        },
        "improper_join_scope": {
          "error_code": "3782",
          "symptom": "Column reference outside scope in JOIN ON",
          "root_cause": "Columns in JOIN ON don't exist in tables being joined",
          "detection": "JOIN ON references tables not in current join",
          "correction_strategy": "Use explicit table aliases (t1, t2), verify columns exist in joined tables",
          "prevention": "All columns in JOIN ON must exist in tables being joined",
          "reference": "TERADATA_FORBIDDEN_PATTERNS.json:F10"
        }
      }
    }
  },
  "correction_workflow": {
    "step_1": "Identify error code and category from error message",
    "step_2": "Look up error in taxonomy to understand root cause",
    "step_3": "Apply correction strategy from taxonomy",
    "step_4": "Check reference file for additional context",
    "step_5": "Validate fix using prevention strategy",
    "step_6": "If fix fails, escalate to diagnostic exploration"
  }
}
